<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Configuring the Generator Framework</title><meta content="DocBook XSL Stylesheets V1.69.1" name="generator"><link rel="start" href="index.html" title="Sympedia GenFw Tutorial 1"><link rel="up" href="index.html" title="Sympedia GenFw Tutorial 1"><link rel="prev" href="ar01s04.html" title="Defining the Templates"><link rel="next" href="ar01s06.html" title="Notes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Configuring the Generator Framework</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ar01s04.html">Prev</a>&nbsp;</td><th align="center" width="60%">&nbsp;</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ar01s06.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en-EN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1014C"></a>Configuring the Generator Framework</h2></div></div><div></div></div><p>Now we have the meta model file and a JET template class. So 
    far nothing special to GenFw has been used. The next steps will 
    show how to configure a GenFw <span class="emphasis"><em>Generator 
    Library</em></span>.</p><div class="orderedlist"><ol type="1"><li><p>Create a <code class="code">model</code> folder in the 
        <code class="code">tutorial1.gen</code> project.</p></li><li><p>In the <code class="code">model</code> folder create a new generator 
        library named <code class="code">beans.genlib</code> (<span class="emphasis"><em>New Wizard | 
        Sympedia Generation | Generator Library</em></span>).</p></li><li><p>Add an <span class="emphasis"><em>Ecore Instantiator</em></span> to the 
        GenLib and in the <span class="emphasis"><em>Properties</em></span> view name it 
        <code class="code">ECORE</code>. This enables GenFw to instantiate meta 
        models that have been produced by EMF (i.e. they are in Ecore 
        format). Note, that (with Ecore) it is not necessary to specify 
        which Ecore model exactly has to be understood. In other words, 
        the Ecore Instantiator is stateless (except for its instance 
        id, the name feature).</p></li><li><p>Add a <span class="emphasis"><em>JET Template</em></span> to the GenLib and 
        in the <span class="emphasis"><em>Properties</em></span> view name it 
        <code class="code">BeanBaseTemplate</code> and enter the template class name 
        <code class="code">tutorial1.gen.BeanBaseTemplate</code>. This enables GenFw 
        to load the template class. Note, that the template class is 
        located in your workspace and is not reachable by normal 
        Eclipse plugin class loaders! GenFw will construct a special 
        class loader to find and load the template class. The challenge 
        here is that the template class, once loaded from the 
        workspace, will most probably attempt to use the input object 
        passed into the generate() method. At the moment GenFw uses the 
        following strategy to construct a ClassLoader: For each 
        ClassLoader of an input object a child 
        <code class="code">URLClassLoader</code> is created (and cached during a 
        generator batch) with all the jars and bin folders in the build 
        path of the Java project that contains the <code class="code">genlib</code> 
        file.</p></li><li><p>Add a <span class="emphasis"><em>Rule Set</em></span> to the GenLib and 
        name it <code class="code">BeanRules</code>.</p></li><li><p>Add a <span class="emphasis"><em>BeanShell Rule</em></span> to the new 
        RuleSet name it <code class="code">BeanBaseRule</code> and choose the 
        generator <code class="code">BeanBaseTemplate</code>. Now enter the 
        <span class="emphasis"><em>Match Expression</em></span> that can decide for which 
        input objects the chosen generator shall be invoked. You may 
        use the identifier <code class="code">self</code> to point to the input 
        object itself. Since we want to invoke the 
        <code class="code">BeanBaseTemplate</code> on every 
        <span class="emphasis"><em>Bean</em></span> element in the meta model, enter 
        <code class="code">self instanceof Bean</code>. Now enter the 
        <span class="emphasis"><em>Target Path Expression</em></span>. This expression 
        must return a value of type String and again you may use 
        <code class="code">self</code> to refer to the input object itself. Note, 
        that the target path expression may either return an absolute 
        path which is interpreted relative to the workspace location or 
        a relative path which is appended to the full path of the 
        project with the genapp file that uses our genlib file. We will 
        soon arrive at what a <span class="emphasis"><em>genapp</em></span> file is. We 
        choose to use a relative path to make our GenLib more reusable: 
        <code class="code">"src-gen/" + self.getBeanLibrary() 
        .getPackageName().replace('.', '/') + 
        "/" + self.getName() + 
        "BeanBase.java"</code>. Finally enter an import 
        statement as <span class="emphasis"><em>Boostrap Code</em></span> for this 
        BeanShellExpression to enable short class names in the 
        expressions (otherwise you should have written <code class="code">self 
        instanceof tutorial1.gen.beans.Bean</code>).</p><div class="figure"><a name="N101C3"></a><p class="title"><b>Figure&nbsp;5.&nbsp;Generator Library created</b></p><div><img src="images/genlibCreatedImg.gif" alt="Generator Library created"></div></div><p>The configuration of the generator library is complete 
        for the moment. Think of this genlib file (and the whole 
        <code class="code">tutorial1.gen</code> project together with the meta model 
        plugins) as a reusable asset for generating bean libraries. 
        This is why it&rsquo;s called a <span class="emphasis"><em>Generator 
        Library</em></span>. Note, that so far we have not specified any 
        concrete input files (meta model instances). This will be our 
        last trail that follows here.</p></li><li><p>Go back to the <code class="code">tutorial1.orderman</code> project 
        and in the model folder create a new <span class="emphasis"><em>Generator 
        Application</em></span> named <code class="code">orderman.genapp</code> 
        (<span class="emphasis"><em>New Wizard | Sympedia Generation | Generator 
        Application</em></span>).</p></li><li><p>Add an <span class="emphasis"><em>Input</em></span> element to the GenApp 
        with the path <code class="code">model/orderman.beans</code>. The property 
        label <span class="emphasis"><em>Full Path</em></span> is actually misleading 
        since input paths can also be relative to the project that 
        contains the genapp file. This makes copying the genapp file to 
        other application easier! To be able to refer to elements of 
        the genlib file, load the <code class="code">beans.genlib</code> resource 
        into the GenApp editor. Now select <code class="code">ECORE</code> as the 
        ContentProvider and <code class="code">BeanRules</code> as a RuleSet to 
        use.</p><div class="figure"><a name="N101F5"></a><p class="title"><b>Figure&nbsp;6.&nbsp;Generator Application created</b></p><div><img src="images/genappCreatedImg.gif" alt="Generator Application created"></div></div></li><li><p>Recall that in the <code class="code">BeanBaseRule</code> we direcetd 
        the output of the generation to the <code class="code">src-gen</code> folder 
        of the GenApp project. Don&rsquo;t forget to add the 
        <code class="code">src-gen</code> source folder to the 
        <code class="code">tutorial1.orderman</code> project now!</p></li><li><p>Save the genapp file and right-click on it in the 
        <span class="emphasis"><em>Package Explorer</em></span>. In the context menu 
        select <span class="emphasis"><em>Sympedia Generation | Generate</em></span>. 
        That&rsquo;s it. Look into the <code class="code">src-ge</code>n folder. GenFw has 
        created a package with the PersonBeanBase class:</p><pre class="programlisting">package tutorial.orderman; 
 
public abstract class PersonBeanBase 
{ 
  protected int id; 
  protected String name; 
  protected double income; 
 
  public PersonBeanBase(int id, String name, double income) 
  { 
    this.id = id; 
    this.name = name; 
    this.income = income; 
  } 
}</pre></li><li><p>To complete the template (getters, setters and listener 
        infrastructure), re-open the <code class="code">BeanBase.javajet</code> file 
        and add the following before the constructor:</p><pre class="programlisting">  private java.util.List&lt;Listener&gt; listeners = new java.util.ArrayList&lt;Listener&gt;();</pre><p>and the following before the last closing brace:</p><pre class="programlisting">&lt;%for (Iterator it = bean.getProperties().iterator(); it.hasNext();) {  
  BeanProperty prop = (BeanProperty)it.next(); 
  String capName = StringHelper.capitalize(prop.getName());%&gt; 
  public &lt;%=prop.getTypeName()%&gt; get&lt;%=capName%&gt;() 
  { 
    return &lt;%=prop.getName()%&gt;; 
  } 
 
  &lt;%if (prop.isChangeable()) {%&gt; 
  public void set&lt;%=capName%&gt;(&lt;%=prop.getTypeName()%&gt; new&lt;%=capName%&gt;) 
  { 
    &lt;%=prop.getTypeName()%&gt; old&lt;%=capName%&gt; = &lt;%=prop.getName()%&gt;; 
    if (!EqualityHelper.equals(old&lt;%=capName%&gt;, new&lt;%=capName%&gt;)) 
    { 
      &lt;%=prop.getName()%&gt; = new&lt;%=capName%&gt;; 
      for (Listener listener : listeners) 
        listener.notify&lt;%=capName%&gt;Changed(this, old&lt;%=capName%&gt;, new&lt;%=capName%&gt;); 
    } 
  } 
 
  &lt;%}%&gt; 
&lt;%}%&gt; 
  public interface Listener 
  { 
&lt;%for (Iterator it = bean.getProperties().iterator(); it.hasNext();) {  
  BeanProperty prop = (BeanProperty)it.next(); 
  if (prop.isChangeable()) { 
    String capName = StringHelper.capitalize(prop.getName());%&gt; 
    void notify&lt;%=capName%&gt;Changed(&lt;%=bean.getName()%&gt;BeanBase source, 
               &lt;%=prop.getTypeName()%&gt; old&lt;%=capName%&gt;, 
               &lt;%=prop.getTypeName()%&gt; new&lt;%=capName%&gt;); 
  &lt;%}%&gt; 
&lt;%}%&gt; 
  }</pre></li><li><p>Note, that the reference to the <code class="code">StringHelper</code> 
        class can&rsquo;t be resolved. This is where the <code class="code">src</code> 
        folder of the <code class="code">tutorial1.gen</code> project comes into 
        play. Create the following helper class in the <code class="code">src</code> 
        folder and re-generate:</p><pre class="programlisting">package tutorial1.gen; 
 
public class StringHelper 
{ 
  public static String capitalize(String text) 
  { 
    if (text == null || text.length() == 0) 
    { 
      return text; 
    } 
 
    if (Character.isLowerCase(text.charAt(0))) 
    { 
      return text.substring(0, 1).toUpperCase() + text.substring(1); 
    } 
 
    return text; 
  } 
}</pre><p>The generated PersonBeanBase contains unresolved 
        references to the <code class="code">EqualityHelper</code> class. We can&rsquo;t 
        create the <code class="code">EqualityHelper</code> in the 
        <code class="code">tutorial1.gen</code> project, since this project is not 
        part of the target application. It is only present during 
        development time and usally never leaves the workspace (except 
        when committing to a repository). We could create it in the 
        <code class="code">tutorial1.orderman</code> project, but that would prevent 
        the generator project from being used in other generator 
        applications. Rather we decide to create a reusable plugin that 
        conatins all the runtime support classes for the generated 
        classes. Typically we will place runtime helper classes here or 
        interfaces that have to be implemented by the generated 
        classes.</p></li><li><p>Create a new Plug-in Project (Java, no Activator, no UI) 
        named <code class="code">tutorial1</code>.</p></li><li><p>Add the Java class <code class="code">tutorial1.EqualityHelper</code> 
        and fill it with the code outlined at the beginning. Don&rsquo;t 
        forget to export the new package in the runtime section of the 
        <code class="code">MANIFEST.MF</code> file.</p></li><li><p>In the 
        <code class="code">tutorial1.orderman/META-INF/MANIFEST.MF</code> file add a 
        dependency on the new <code class="code">tutorial1</code> plugin.</p><div class="figure"><a name="N1025F"></a><p class="title"><b>Figure&nbsp;7.&nbsp;Platform plugin created</b></p><div><img src="images/platformCreatedImg.gif" alt="Platform plugin created"></div></div></li><li><p>Note, that the <code class="code">EqualityHelper</code> class is in a 
        package different from the package of the generated beans. Add 
        an import statement to template!</p><p>Now the only problem is the missing PersonBean class. We 
        could use the <span class="emphasis"><em>New Class</em></span> wizard to derive 
        it from PersonBeanBase by hand (and add the various business 
        methods), but, recalling that many many beans will follow this 
        first one, we decide to let GenFw create (empty) default 
        implementations of the derived classes. This is a minor 
        violation of our requirement that generated code goes to 
        <code class="code">src-gen</code> always, but we accept this because GenFw 
        never touches existing files, if we mark the Rule as 
        <span class="emphasis"><em>Dont Overwrite</em></span> in the GenLib. Never forget 
        about this!</p></li><li><p>Add the new template <code class="code">Bean.javajet</code> to the 
        generator project:</p><pre class="programlisting">&lt;%@ jet package="tutorial1.gen"  
        imports="java.util.* tutorial1.gen.beans.*"  
        class="BeanTemplate"%&gt; 
&lt;%Bean bean = (Bean)argument;%&gt; 
package &lt;%=bean.getBeanLibrary().getPackageName()%&gt;; 
 
public class &lt;%=bean.getName()%&gt;Bean extends &lt;%=bean.getName()%&gt;BeanBase 
{ 
  public &lt;%=bean.getName()%&gt;Bean(&lt;%=BeanHelper.formatParameters(bean, true)%&gt;) 
  { 
    super(&lt;%=BeanHelper.formatParameterNames(bean, false)%&gt;); 
  } 
   
  ///////////////////////////////////////////////////////////////////// 
  // Business methods 
  ///////////////////////////////////////////////////////////////////// 
 
}</pre></li><li><p>Add the missing class <code class="code">BeanHelper</code> to the 
        generator project <code class="code">tutorial1.gen</code>, it is only used 
        during generation:</p><pre class="programlisting">package tutorial1.gen; 
 
import tutorial1.gen.beans.Bean; 
import tutorial1.gen.beans.BeanProperty; 
import java.util.Iterator; 
 
public class BeanHelper 
{ 
  public static String formatParameters(Bean bean, boolean withTypes) 
  { 
    StringBuffer buffer = new StringBuffer(); 
    for (Iterator it = bean.getProperties().iterator(); it.hasNext();) 
    { 
      BeanProperty prop = (BeanProperty)it.next(); 
      if (withTypes) 
      { 
        buffer.append(prop.getTypeName()); 
        buffer.append(" "); 
      } 
 
      buffer.append(prop.getName()); 
      if (it.hasNext()) buffer.append(", "); 
    } 
 
    return buffer.toString(); 
  } 
}</pre><p>Consider to refactor the other template to profit from 
        the new helper method <code class="code">formatParameters()</code>. Btw. an 
        even better place for this method is the meta model itself. 
        Then you can call from the templates and elsewhere: 
        <code class="code">bean.formatParameters(true)</code> instead of 
        <code class="code">BeanHelper.formatParameters(bean, true)</code>. Since 
        this is more &bdquo;OO&ldquo;, it will be easier to extend the meta model 
        later. Don&rsquo;t forget to export the meta model as deployable 
        plugins after modifications, otherwise you will continue to 
        work with the old versions. In the worst case you can corrupt 
        existing meta model instances!</p><p>Note for repeated exports of the same plugins: When you 
        change certain settings in the <code class="code">MANIFEST.MF</code> 
        (especially dependencies) before re-exporting, Eclipse tends to 
        keep stale entries in its caches, even if you specify the 
        <code class="code">&ndash;clear</code> option. The problem will manifest itself 
        through weird errors that are often hard to understand. As a 
        workaround I do the following: Backup all my Eclipse 
        preferences to an .epf file, exit Eclipse, delete everything in 
        the configuration folder of eclipse (except the config.ini!!!), 
        re-start Eclipse and import the previously exported 
        preferences. It&rsquo;s kind of annoying, but it works ;-)</p><p>To reduce the number of re-exports, you can launch a 
        runtime workbench of course. There you can test your meta model 
        until it is free of errors. Another trick is to use a local 
        update site so that you can install the new meta model plugins 
        into the running Eclipse instance. Then you need two additional 
        projects for the feature and the update site. If you go this 
        way, don&rsquo;t forget to increase the version numbers each time 
        before you publish the feature!</p></li><li><p>Re-open the GenLib file and add a second JETTemplate 
        generator named <code class="code">BeanTemplate</code>.</p></li><li><p>To the existing RuleSet add a second BeanShellRule (or 
        copy and edit the first one). The most important thing here is 
        to not forget switching <span class="emphasis"><em>Dont Overwrite</em></span> to 
        <code class="code">true</code>!!! It should look like this:</p><div class="figure"><a name="N102AF"></a><p class="title"><b>Figure&nbsp;8.&nbsp;Rule that never overwrites existing files</b></p><div><img src="images/initialTemplateImg.gif" alt="Rule that never overwrites existing files"></div></div></li><li><p>Re-generate.</p></li><li><p>Add the business methods to the <code class="code">PersonBean</code> 
        class. You can be sure that this file will never be touched 
        again by GenFw. Note, that this might become a problem if you 
        decide to change the templates and the relation between 
        <code class="code">BeanBase</code> and <code class="code">Bean</code>!</p></li><li><p>Finally integrate the GenFw generation into your 
        automated build script. For this purpose there is an 
        <span class="emphasis"><em>Ant</em></span> task that you can use as 
        follows:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;project name="tutorial1.orderman" default="generate" basedir="."&gt; 
 
  &lt;target name="generate"&gt; 
    &lt;genfw genapp="/tutorial.orderman/model/orderman.genapp" tracelevel="4" /&gt; 
  &lt;/target&gt; 
 
&lt;/project&gt;</pre></li></ol></div><p>That&rsquo;s it! Because during normal development you will invoke 
    the generator as often as possible (and necessary) and because you 
    may want to add other GenApp files there is the Eclipse view 
    <span class="emphasis"><em>Generator Applications</em></span> (category 
    <span class="emphasis"><em>Sympedia Generation</em></span>). It lists all the GenApps 
    and GenLibs in your workspace and you can open them from here. You 
    can run the <span class="emphasis"><em>Generate</em></span> action on all or selected 
    GenApps from here. You can even switch on a second tree level to 
    show all the inputs (meta model instances) of the GenApps.</p><div class="figure"><a name="N102D8"></a><p class="title"><b>Figure&nbsp;9.&nbsp;Generator Applications view</b></p><div><img src="images/genappsViewImg.gif" alt="Generator Applications view"></div></div></div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ar01s04.html">Prev</a>&nbsp;</td><td align="center" width="20%">&nbsp;</td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ar01s06.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">Defining the Templates&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;Notes</td></tr></table></div></body></html>