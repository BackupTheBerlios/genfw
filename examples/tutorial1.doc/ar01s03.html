<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Steps</title><meta content="DocBook XSL Stylesheets V1.69.1" name="generator"><link rel="start" href="index.html" title="Sympedia GenFw Tutorial 1"><link rel="up" href="index.html" title="Sympedia GenFw Tutorial 1"><link rel="prev" href="ar01s02.html" title="Concepts"><link rel="next" href="ar01s04.html" title="Notes"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Steps</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ar01s02.html">Prev</a>&nbsp;</td><th align="center" width="60%">&nbsp;</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ar01s04.html">Next</a></td></tr></table><hr></div><div class="sect1" lang="en-EN"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1007D"></a>Steps</h2></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>Create the project <code class="code">tutorial1.gen.beans</code> with 
        the Empty EMF Project wizard.</p></li><li><p>Create a folder <code class="code">model</code> in that project.</p></li><li><p>Create the <code class="code">beans.ecore</code> and the 
        <code class="code">beans.genmodel</code> file (you know how to do 
        this).</p></li><li><p>Generate the meta model plugins with EMF and compare your 
        workspace with this one:</p><div class="figure"><a name="N1009B"></a><p class="title"><b>Figure&nbsp;2.&nbsp;Meta Model generated</b></p><div><img src="images/mmGeneratedImg.gif" alt="Meta Model generated"></div></div></li><li><p>Export the three plugins to the install location of your 
        Eclipse instance.</p></li><li><p>Close the plugin projects and restart your Eclipse 
        instance.</p></li><li><p>To test the new meta model, create a new Plug-in Project 
        <code class="code">tutorial1.orderman</code>. We don&rsquo;t need an Activator 
        class or UI support. This will become our Eclipse library for 
        <span class="emphasis"><em>Order Management</em></span> beans.</p></li><li><p>Create a <code class="code">model</code> folder in that project.</p></li><li><p>Use the <span class="emphasis"><em>New Beans Model</em></span> wizard that 
        EMF has generated for you to create the 
        <code class="code">orderman.beans</code> file. Select the <span class="emphasis"><em>Bean 
        Library</em></span> as the (root) model object.</p></li><li><p>In the generated <span class="emphasis"><em>Beans Model Editor</em></span> 
        (should open automatically after model file creation) you can 
        already see the root object of the model, the <span class="emphasis"><em>Bean 
        Library</em></span>. Obviously the model is ready now to be 
        populated with concrete Beans and their BeanProperties. For the 
        PersonBean example introduced at the beginning, it could look 
        like this:</p><div class="figure"><a name="N100CB"></a><p class="title"><b>Figure&nbsp;3.&nbsp;Instance of the Meta Model created</b></p><div><img src="images/mmFileCreatedImg.gif" alt="Instance of the Meta Model created"></div></div></li><li><p>After saving the model you should have a file with the 
        following XML content:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;beans:BeanLibrary xmi:version="2.0"  
    xmlns:xmi="http://www.omg.org/XMI"  
    xmlns:beans="http://beans"  
    name="Order Management"  
    packageName="tutorial1.orderman"&gt; 
  &lt;beans name="Person"&gt; 
    &lt;properties name="id" typeName="int"/&gt; 
    &lt;properties name="name" typeName="String" changeable="true"/&gt; 
    &lt;properties name="income" typeName="double" changeable="true"/&gt; 
  &lt;/beans&gt; 
&lt;/beans:BeanLibrary&gt;</pre><p>Now that we have a formal description of the beans we 
        want to generate, we have to think about how to specify the 
        similarities of all our bean classes. We decide to use 
        <span class="emphasis"><em>JET</em></span> templates for that purpose. Support 
        for generation with JET templates comes with the EMF 
        distribution and should be available right now. Maybe you know 
        already that there is a distinction between 
        <span class="emphasis"><em>JET</em></span> that simply produces text output and 
        <span class="emphasis"><em>JMerge</em></span> that expects this output to be Java 
        source code and merges it with changes you have applied to 
        former generation results. Anyway, we decide not to use JMerge, 
        because we don&rsquo;t like to mix generated code with hand-written 
        code. Rather we like to be sure that our hand-written source is 
        never touched by a generator and that, in the event that 
        something goes wrong, we can simply delete the generated files 
        and let them be re-generated.</p><p>Just recall that the only challenge with hand-written 
        code in our example is caused by the <span class="emphasis"><em>business 
        methods</em></span> requirement. Now you should realize that our 
        beans meta model does not contain the notion of a business 
        method. Of course it would easily be possible to model Java 
        methods and their parameters, but we decide to try another 
        approach. The classes we are generating are abstract super 
        classes of the bean classes we are exposing. We will generate 
        the base classes to the <code class="code">src-gen</code> folder of the 
        project and provide (hand-written) derived classes in the 
        <code class="code">src</code> folder. The derived classes can be augmented 
        with the required business methods, we don&rsquo;t need to write the 
        repeating bean infrastructure ourselves and the generator will 
        never touch our additions.</p><p>JET templates are written in a <span class="emphasis"><em>JSP</em></span> 
        like syntax and then compiled to Java classes by the JET 
        template compiler. Later these template classes will be loaded 
        by GenFw and used to produce the Java source code for our bean 
        descriptions.</p></li><li><p>Create the plugin project <code class="code">tutorial1.gen</code> 
        (Java, but no Activator, no UI).</p></li><li><p>Add the <code class="code">src-gen</code> source folder.</p></li><li><p>Use the New Wizard <span class="emphasis"><em>Convert Projects to JET 
        Projects</em></span> and select the <code class="code">tutorial1.gen</code> 
        project for conversion. The <code class="code">templates</code> folder 
        should appear.</p></li><li><p>Go to the properties of the new project and browse to the 
        <span class="emphasis"><em>JET Settings</em></span> category. Enter the path of 
        the <span class="emphasis"><em>Source Container</em></span> to let the JET 
        compiler produce the template classes in the 
        <code class="code">src-gen</code> folder.</p></li><li><p>Because the template we will be writing refers to our 
        meta model, add a dependency on the 
        <code class="code">tutorial1.gen.beans</code> plugin to the 
        <span class="emphasis"><em>MANIFEST.MF</em></span> of the 
        <code class="code">tutorial1.gen</code> project.</p></li><li><p>Now create the template source file 
        <code class="code">BeanBase.javajet</code> in the <code class="code">templates</code> 
        folder. Editing this file can be much, much more convenient, if 
        you download and install the 
        <code class="code">org.eclipse.emf.codegen.jet.editor</code> plugin from the 
        <span class="emphasis"><em>Merlin Generator</em></span> project. At the moment 
        the following content should enable us to quickly continue on 
        the road to our first generated PersonBean:</p><pre class="programlisting">&lt;%@ jet package="tutorial1.gen"  
        imports="java.util.* tutorial1.gen.beans.*"  
        class="BeanBaseTemplate"%&gt; 
&lt;% 
Bean bean = (Bean)argument; 
 
StringBuffer buffer = new StringBuffer(); 
for (Iterator it = bean.getProperties().iterator(); it.hasNext();) 
{  
  BeanProperty prop = (BeanProperty)it.next(); 
  buffer.append(prop.getTypeName()); 
  buffer.append(" "); 
  buffer.append(prop.getName()); 
  if (it.hasNext()) buffer.append(", "); 
} 
 
String ctorParams = buffer.toString();  
%&gt; 
package &lt;%=bean.getBeanLibrary().getPackageName()%&gt;; 
 
public abstract class &lt;%=bean.getName()%&gt;BeanBase 
{ 
&lt;%for (Iterator it = bean.getProperties().iterator(); it.hasNext();) {  
  BeanProperty prop = (BeanProperty)it.next();%&gt; 
  protected &lt;%=prop.getTypeName()%&gt; &lt;%=prop.getName()%&gt;; 
&lt;%}%&gt; 
 
  public &lt;%=bean.getName()%&gt;BeanBase(&lt;%=ctorParams%&gt;) 
  { 
&lt;%for (Iterator it = bean.getProperties().iterator(); it.hasNext();) {  
  BeanProperty prop = (BeanProperty)it.next();%&gt; 
    this.&lt;%=prop.getName()%&gt; = &lt;%=prop.getName()%&gt;; 
&lt;%}%&gt; 
  } 
}</pre><p>This looks a bit weird, but with more experience you will 
        like the fact that the template logic is written in Java (and 
        compiled to Java classes). The above template definition shall 
        produce the base class skeleton with the fields and the 
        constructor.</p><div class="figure"><a name="N10136"></a><p class="title"><b>Figure&nbsp;4.&nbsp;JET template created</b></p><div><img src="images/templateCreatedImg.gif" alt="JET template created"></div></div><p>You should verify that the JET compiler has written the 
        compiled templates to the proper location 
        <code class="code">/tutorial1.gen/src-gen/tutorial1.gen/BeanBaseTemplate.java</code>.</p><p>Note, that the <code class="code">src</code> folder is still empty. We 
        will need it later, when we provide static helper methods that 
        have to be reachable by the template code.</p><p>Now we have the meta model file and a JET template class. 
        So far nothing special to GenFw has been used. The next steps 
        will show how to configure a GenFw <span class="emphasis"><em>Generator 
        Library</em></span>.</p></li><li><p>Create a <code class="code">model</code> folder in the 
        <code class="code">tutorial1.gen</code> project.</p></li><li><p>In the <code class="code">model</code> folder create a new generator 
        library named <code class="code">beans.genlib</code> (<span class="emphasis"><em>New Wizard | 
        Sympedia Generation | Generator Library</em></span>).</p></li><li><p>Add an <span class="emphasis"><em>EcoreContentProvider</em></span> to the 
        GenLib and in the <span class="emphasis"><em>Properties</em></span> view name it 
        <code class="code">ECORE</code>. This enables GenFw to instantiate meta 
        models that have been produced by EMF (i.e. they are in Ecore 
        format). Note, that (with Ecore) it is not necessary to specify 
        which Ecore model exactly has to be understood. In other words, 
        the EcoreContentProvider is stateless (except for its instance 
        id, the name feature).</p></li><li><p>Add a <span class="emphasis"><em>JETTemplate</em></span> to the GenLib and 
        in the <span class="emphasis"><em>Properties</em></span> view name it 
        <code class="code">BeanBaseTemplate</code> and enter the template class name 
        <code class="code">tutorial1.gen.BeanBaseTemplate</code>. This enables GenFw 
        to load the template class. Note, that the template class is 
        located in your workspace and is not reachable by normal 
        Eclipse plugin class loaders! GenFw will construct a special 
        class loader to find and load the template class. The challenge 
        here is that the template class, once loaded from the 
        workspace, will most probably attempt to use the input object 
        passed into the generate() method. At the moment GenFw uses the 
        following strategy to construct a ClassLoader: For each 
        ClassLoader of an input object a child 
        <code class="code">URLClassLoader</code> is created (and cached during a 
        generator batch) with all the jars and bin folders in the build 
        path of the Java project that contains the <code class="code">genlib</code> 
        file.</p></li><li><p>Add a <span class="emphasis"><em>RuleSet</em></span> to the GenLib and name 
        it <code class="code">BeanRules</code>.</p></li><li><p>Add a <span class="emphasis"><em>BeanShellRule</em></span> to the new 
        RuleSet name it <code class="code">BeanBaseRule</code> and choose the 
        generator <code class="code">BeanBaseTemplate</code>. Now enter the 
        <span class="emphasis"><em>Match Expression</em></span> that can decide for which 
        input objects the chosen generator shall be invoked. You may 
        use the identifier <code class="code">self</code> to point to the input 
        object itself. Since we want to invoke the 
        <code class="code">BeanBaseTemplate</code> on every 
        <span class="emphasis"><em>Bean</em></span> element in the meta model, enter 
        <code class="code">self instanceof Bean</code>. Now enter the 
        <span class="emphasis"><em>Target Path Expression</em></span>. This expression 
        must return a value of type String and again you may use 
        <code class="code">self</code> to refer to the input object itself. Note, 
        that the target path expression may either return an absolute 
        path which is interpreted relative to the workspace location or 
        a relative path which is appended to the full path of the 
        project with the genapp file that uses our genlib file. We will 
        soon arrive at what a <span class="emphasis"><em>genapp</em></span> file is. We 
        choose to use a relative path to make our GenLib more reusable: 
        <code class="code">"src-gen/" + self.getBeanLibrary() 
        .getPackageName().replace('.', '/') + 
        "/" + self.getName() + 
        "BeanBase.java"</code>. Finally enter an import 
        statement as <span class="emphasis"><em>Boostrap Code</em></span> for this 
        BeanShellExpression to enable short class names in the 
        expressions (otherwise you should have written <code class="code">self 
        instanceof tutorial1.gen.beans.Bean</code>).</p><div class="figure"><a name="N101B7"></a><p class="title"><b>Figure&nbsp;5.&nbsp;Generator Library created</b></p><div><img src="images/genlibCreatedImg.gif" alt="Generator Library created"></div></div><p>The configuration of the generator library is complete 
        for the moment. Think of this genlib file (and the whole 
        <code class="code">tutorial1.gen</code> project together with the meta model 
        plugins) as a reusable asset for generating bean libraries. 
        This is why it&rsquo;s called a <span class="emphasis"><em>Generator 
        Library</em></span>. Note, that so far we have not specified any 
        concrete input files (meta model instances). This will be our 
        last trail that follows here.</p></li><li><p>Go back to the <code class="code">tutorial1.orderman</code> project 
        and in the model folder create a new <span class="emphasis"><em>Generator 
        Application</em></span> named <code class="code">orderman.genapp</code> 
        (<span class="emphasis"><em>New Wizard | Sympedia Generation | Generator 
        Application</em></span>).</p></li><li><p>Add an <span class="emphasis"><em>Input</em></span> element to the GenApp 
        with the path <code class="code">model/orderman.beans</code>. The property 
        label <span class="emphasis"><em>Full Path</em></span> is actually misleading 
        since input paths can also be relative to the project that 
        contains the genapp file. This makes copying the genapp file to 
        other application easier! To be able to refer to elements of 
        the genlib file, load the <code class="code">beans.genlib</code> resource 
        into the GenApp editor. Now select <code class="code">ECORE</code> as the 
        ContentProvider and <code class="code">BeanRules</code> as a RuleSet to 
        use.</p><div class="figure"><a name="N101E9"></a><p class="title"><b>Figure&nbsp;6.&nbsp;Generator Application created</b></p><div><img src="images/genappCreatedImg.gif" alt="Generator Application created"></div></div></li><li><p>Recall that in the <code class="code">BeanBaseRule</code> we direcetd 
        the output of the generation to the <code class="code">src-gen</code> folder 
        of the GenApp project. Don&rsquo;t forget to add the 
        <code class="code">src-gen</code> source folder to the 
        <code class="code">tutorial1.orderman</code> project now!</p></li><li><p>Save the genapp file and right-click on it in the 
        <span class="emphasis"><em>Package Explorer</em></span>. In the context menu 
        select <span class="emphasis"><em>Sympedia Generation | Generate</em></span>. 
        That&rsquo;s it. Look into the <code class="code">src-ge</code>n folder. GenFw has 
        created a package with the PersonBeanBase class:</p><pre class="programlisting">package tutorial.orderman; 
 
public abstract class PersonBeanBase 
{ 
  protected int id; 
  protected String name; 
  protected double income; 
 
  public PersonBeanBase(int id, String name, double income) 
  { 
    this.id = id; 
    this.name = name; 
    this.income = income; 
  } 
}</pre></li><li><p>To complete the template (getters, setters and listener 
        infrastructure), re-open the <code class="code">BeanBase.javajet</code> file 
        and add the following before the constructor:</p><pre class="programlisting">  private java.util.List&lt;Listener&gt; listeners = new java.util.ArrayList&lt;Listener&gt;();</pre><p>and the following before the last closing brace:</p><pre class="programlisting">&lt;%for (Iterator it = bean.getProperties().iterator(); it.hasNext();) {  
  BeanProperty prop = (BeanProperty)it.next(); 
  String capName = StringHelper.capitalize(prop.getName());%&gt; 
  public &lt;%=prop.getTypeName()%&gt; get&lt;%=capName%&gt;() 
  { 
    return &lt;%=prop.getName()%&gt;; 
  } 
 
  &lt;%if (prop.isChangeable()) {%&gt; 
  public void set&lt;%=capName%&gt;(&lt;%=prop.getTypeName()%&gt; new&lt;%=capName%&gt;) 
  { 
    &lt;%=prop.getTypeName()%&gt; old&lt;%=capName%&gt; = &lt;%=prop.getName()%&gt;; 
    if (!EqualityHelper.equals(old&lt;%=capName%&gt;, new&lt;%=capName%&gt;)) 
    { 
      &lt;%=prop.getName()%&gt; = new&lt;%=capName%&gt;; 
      for (Listener listener : listeners) 
        listener.notify&lt;%=capName%&gt;Changed(this, old&lt;%=capName%&gt;, new&lt;%=capName%&gt;); 
    } 
  } 
 
  &lt;%}%&gt; 
&lt;%}%&gt; 
  public interface Listener 
  { 
&lt;%for (Iterator it = bean.getProperties().iterator(); it.hasNext();) {  
  BeanProperty prop = (BeanProperty)it.next(); 
  if (prop.isChangeable()) { 
    String capName = StringHelper.capitalize(prop.getName());%&gt; 
    void notify&lt;%=capName%&gt;Changed(&lt;%=bean.getName()%&gt;BeanBase source, 
               &lt;%=prop.getTypeName()%&gt; old&lt;%=capName%&gt;, 
               &lt;%=prop.getTypeName()%&gt; new&lt;%=capName%&gt;); 
  &lt;%}%&gt; 
&lt;%}%&gt; 
  }</pre></li><li><p>Note, that the reference to the <code class="code">StringHelper</code> 
        class can&rsquo;t be resolved. This is where the <code class="code">src</code> 
        folder of the <code class="code">tutorial1.gen</code> project comes into 
        play. Create the following helper class in the <code class="code">src</code> 
        folder and re-generate:</p><pre class="programlisting">package tutorial1.gen; 
 
public class StringHelper 
{ 
  public static String capitalize(String text) 
  { 
    if (text == null || text.length() == 0) 
    { 
      return text; 
    } 
 
    if (Character.isLowerCase(text.charAt(0))) 
    { 
      return text.substring(0, 1).toUpperCase() + text.substring(1); 
    } 
 
    return text; 
  } 
}</pre><p>The generated PersonBeanBase contains unresolved 
        references to the <code class="code">EqualityHelper</code> class. We can&rsquo;t 
        create the <code class="code">EqualityHelper</code> in the 
        <code class="code">tutorial1.gen</code> project, since this project is not 
        part of the target application. It is only present during 
        development time and usally never leaves the workspace (except 
        when committing to a repository). We could create it in the 
        <code class="code">tutorial1.orderman</code> project, but that would prevent 
        the generator project from being used in other generator 
        applications. Rather we decide to create a reusable plugin that 
        conatins all the runtime support classes for the generated 
        classes. Typically we will place runtime helper classes here or 
        interfaces that have to be implemented by the generated 
        classes.</p></li><li><p>Create a new Plug-in Project (Java, no Activator, no UI) 
        named <code class="code">tutorial1</code>.</p></li><li><p>Add the Java class <code class="code">tutorial1.EqualityHelper</code> 
        and fill it with the code outlined at the beginning. Don&rsquo;t 
        forget to export the new package in the runtime section of the 
        <code class="code">MANIFEST.MF</code> file.</p></li><li><p>In the 
        <code class="code">tutorial1.orderman/META-INF/MANIFEST.MF</code> file add a 
        dependency on the new <code class="code">tutorial1</code> plugin.</p><div class="figure"><a name="N10253"></a><p class="title"><b>Figure&nbsp;7.&nbsp;Platform plugin created</b></p><div><img src="images/platformCreatedImg.gif" alt="Platform plugin created"></div></div></li><li><p>Note, that the <code class="code">EqualityHelper</code> class is in a 
        package different from the package of the generated beans. Add 
        an import statement to template!</p><p>Now the only problem is the missing PersonBean class. We 
        could use the <span class="emphasis"><em>New Class</em></span> wizard to derive 
        it from PersonBeanBase by hand (and add the various business 
        methods), but, recalling that many many beans will follow this 
        first one, we decide to let GenFw create (empty) default 
        implementations of the derived classes. This is a minor 
        violation of our requirement that generated code goes to 
        <code class="code">src-gen</code> always, but we accept this because GenFw 
        never touches existing files, if we mark the Rule as 
        <span class="emphasis"><em>Dont Overwrite</em></span> in the GenLib. Never forget 
        about this!</p></li><li><p>Add the new template <code class="code">Bean.javajet</code> to the 
        generator project:</p><pre class="programlisting">&lt;%@ jet package="tutorial1.gen"  
        imports="java.util.* tutorial1.gen.beans.*"  
        class="BeanTemplate"%&gt; 
&lt;%Bean bean = (Bean)argument;%&gt; 
package &lt;%=bean.getBeanLibrary().getPackageName()%&gt;; 
 
public class &lt;%=bean.getName()%&gt;Bean extends &lt;%=bean.getName()%&gt;BeanBase 
{ 
  public &lt;%=bean.getName()%&gt;Bean(&lt;%=BeanHelper.formatParameters(bean, true)%&gt;) 
  { 
    super(&lt;%=BeanHelper.formatParameterNames(bean, false)%&gt;); 
  } 
   
  ///////////////////////////////////////////////////////////////////// 
  // Business methods 
  ///////////////////////////////////////////////////////////////////// 
 
}</pre></li><li><p>Add the missing class <code class="code">BeanHelper</code> to the 
        generator project <code class="code">tutorial1.gen</code>, it is only used 
        during generation:</p><pre class="programlisting">package tutorial1.gen; 
 
import tutorial1.gen.beans.Bean; 
import tutorial1.gen.beans.BeanProperty; 
import java.util.Iterator; 
 
public class BeanHelper 
{ 
  public static String formatParameters(Bean bean, boolean withTypes) 
  { 
    StringBuffer buffer = new StringBuffer(); 
    for (Iterator it = bean.getProperties().iterator(); it.hasNext();) 
    { 
      BeanProperty prop = (BeanProperty)it.next(); 
      if (withTypes) 
      { 
        buffer.append(prop.getTypeName()); 
        buffer.append(" "); 
      } 
 
      buffer.append(prop.getName()); 
      if (it.hasNext()) buffer.append(", "); 
    } 
 
    return buffer.toString(); 
  } 
}</pre><p>Consider to refactor the other template to profit from 
        the new helper method <code class="code">formatParameters()</code>. Btw. an 
        even better place for this method is the meta model itself. 
        Then you can call from the templates and elsewhere: 
        <code class="code">bean.formatParameters(true)</code> instead of 
        <code class="code">BeanHelper.formatParameters(bean, true)</code>. Since 
        this is more &bdquo;OO&ldquo;, it will be easier to extend the meta model 
        later. Don&rsquo;t forget to export the meta model as deployable 
        plugins after modifications, otherwise you will continue to 
        work with the old versions. In the worst case you can corrupt 
        existing meta model instances!</p><p>Note for repeated exports of the same plugins: When you 
        change certain settings in the <code class="code">MANIFEST.MF</code> 
        (especially dependencies) before re-exporting, Eclipse tends to 
        keep stale entries in its caches, even if you specify the 
        <code class="code">&ndash;clear</code> option. The problem will manifest itself 
        through weird errors that are often hard to understand. As a 
        workaround I do the following: Backup all my Eclipse 
        preferences to an .epf file, exit Eclipse, delete everything in 
        the configuration folder of eclipse (except the config.ini!!!), 
        re-start Eclipse and import the previously exported 
        preferences. It&rsquo;s kind of annoying, but it works ;-)</p><p>To reduce the number of re-exports, you can launch a 
        runtime workbench of course. There you can test your meta model 
        until it is free of errors. Another trick is to use a local 
        update site so that you can install the new meta model plugins 
        into the running Eclipse instance. Then you need two additional 
        projects for the feature and the update site. If you go this 
        way, don&rsquo;t forget to increase the version numbers each time 
        before you publish the feature!</p></li><li><p>Re-open the GenLib file and add a second JETTemplate 
        generator named <code class="code">BeanTemplate</code>.</p></li><li><p>To the existing RuleSet add a second BeanShellRule (or 
        copy and edit the first one). The most important thing here is 
        to not forget switching <span class="emphasis"><em>Dont Overwrite</em></span> to 
        <code class="code">true</code>!!! It should look like this:</p><div class="figure"><a name="N102A3"></a><p class="title"><b>Figure&nbsp;8.&nbsp;Rule that never overwrites existing files</b></p><div><img src="images/initialTemplateImg.gif" alt="Rule that never overwrites existing files"></div></div></li><li><p>Re-generate.</p></li><li><p>Add the business methods to the <code class="code">PersonBean</code> 
        class. You can be sure that this file will never be touched 
        again by GenFw. Note, that this might become a problem if you 
        decide to change the templates and the relation between 
        <code class="code">BeanBase</code> and <code class="code">Bean</code>!</p></li><li><p>Finally integrate the GenFw generation into your 
        automated build script. For this purpose there is an 
        <span class="emphasis"><em>Ant</em></span> task that you can use as 
        follows:</p><pre class="programlisting">&lt;?xml version="1.0" encoding="UTF-8"?&gt; 
&lt;project name="tutorial1.orderman" default="generate" basedir="."&gt; 
 
  &lt;target name="generate"&gt; 
    &lt;genfw genapp="/tutorial.orderman/model/orderman.genapp" tracelevel="4" /&gt; 
  &lt;/target&gt; 
 
&lt;/project&gt;</pre></li></ol></div><p>That&rsquo;s it! Because during normal development you will invoke 
    the generator as often as possible (and necessary) and because you 
    may want to add other GenApp files there is the Eclipse view 
    <span class="emphasis"><em>Generator Applications</em></span> (category 
    <span class="emphasis"><em>Sympedia Generation</em></span>). It lists all the GenApps 
    and GenLibs in your workspace and you can open them from here. You 
    can run the <span class="emphasis"><em>Generate</em></span> action on all or selected 
    GenApps from here. You can even switch on a second tree level to 
    show all the inputs (meta model instances) of the GenApps.</p><div class="figure"><a name="N102CC"></a><p class="title"><b>Figure&nbsp;9.&nbsp;Generator Applications view</b></p><div><img src="images/genappsViewImg.gif" alt="Generator Applications view"></div></div></div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ar01s02.html">Prev</a>&nbsp;</td><td align="center" width="20%">&nbsp;</td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ar01s04.html">Next</a></td></tr><tr><td valign="top" align="left" width="40%">Concepts&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html">Home</a></td><td valign="top" align="right" width="40%">&nbsp;Notes</td></tr></table></div></body></html>